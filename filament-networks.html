<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>filament-networks</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #020203; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// FILAMENT NETWORKS - Branching lines with pulsing nodes
let filaments = [];
let nodes = [];
let time = 0;
const NODE_COUNT = 15;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  
  // Create nodes
  for (let i = 0; i < NODE_COUNT; i++) {
    nodes.push(createNode());
  }
  
  // Create filaments between nearby nodes
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      let d = dist(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
      if (d < 300 && random() < 0.6) {
        filaments.push({
          from: nodes[i],
          to: nodes[j],
          phase: random(TWO_PI),
          pulseSpeed: random(0.01, 0.03),
          segments: floor(d / 20)
        });
      }
    }
  }
}

function createNode() {
  return {
    x: random(width * 0.1, width * 0.9),
    y: random(height * 0.1, height * 0.9),
    vx: random(-0.3, 0.3),
    vy: random(-0.3, 0.3),
    hue: random(340, 380) % 360,
    phase: random(TWO_PI),
    pulseSpeed: random(0.02, 0.05),
    size: random(8, 20),
    connections: 0
  };
}

function draw() {
  background(240, 15, 0.8, 0.04);
  
  time += 0.016;
  
  // Update nodes
  for (let n of nodes) {
    n.x += n.vx;
    n.y += n.vy;
    
    // Bounce off edges
    if (n.x < 50 || n.x > width - 50) n.vx *= -1;
    if (n.y < 50 || n.y > height - 50) n.vy *= -1;
    
    n.x = constrain(n.x, 50, width - 50);
    n.y = constrain(n.y, 50, height - 50);
    
    // Count connections
    n.connections = filaments.filter(f => f.from === n || f.to === n).length;
  }
  
  // Draw filaments
  for (let f of filaments) {
    drawFilament(f);
  }
  
  // Draw nodes
  for (let n of nodes) {
    drawNode(n);
  }
}

function drawFilament(f) {
  let pulse = sin(frameCount * f.pulseSpeed + f.phase);
  let alpha = map(pulse, -1, 1, 0.1, 0.4);
  
  // Draw curved filament through segments
  noFill();
  strokeWeight(1);
  
  let fromHue = f.from.hue;
  let toHue = f.to.hue;
  
  beginShape();
  for (let i = 0; i <= f.segments; i++) {
    let t = i / f.segments;
    
    // Interpolate position with curve
    let x = lerp(f.from.x, f.to.x, t);
    let y = lerp(f.from.y, f.to.y, t);
    
    // Add perpendicular offset for curve
    let perpX = -(f.to.y - f.from.y);
    let perpY = f.to.x - f.from.x;
    let len = sqrt(perpX * perpX + perpY * perpY);
    if (len > 0) {
      perpX /= len;
      perpY /= len;
    }
    
    let curve = sin(t * PI) * 30 * pulse;
    x += perpX * curve;
    y += perpY * curve;
    
    let hue = lerp(fromHue, toHue, t);
    stroke(hue, 50, 40, alpha);
    vertex(x, y);
  }
  endShape();
  
  // Secondary filament offset
  beginShape();
  for (let i = 0; i <= f.segments; i++) {
    let t = i / f.segments;
    let x = lerp(f.from.x, f.to.x, t);
    let y = lerp(f.from.y, f.to.y, t);
    
    let perpX = -(f.to.y - f.from.y);
    let perpY = f.to.x - f.from.x;
    let len = sqrt(perpX * perpX + perpY * perpY);
    if (len > 0) {
      perpX /= len;
      perpY /= len;
    }
    
    let curve = sin(t * PI) * 30 * pulse + 15;
    x += perpX * curve;
    y += perpY * curve;
    
    let hue = lerp(fromHue, toHue, t);
    stroke(hue, 40, 60, alpha * 0.5);
    vertex(x, y);
  }
  endShape();
}

function drawNode(n) {
  let pulse = sin(frameCount * n.pulseSpeed + n.phase);
  let size = n.size * (0.8 + pulse * 0.2);
  let brightness = map(pulse, -1, 1, 30, 70);
  
  // Outer glow based on connections
  let glowSize = size + n.connections * 5;
  noStroke();
  for (let r = glowSize * 2; r > size; r -= 4) {
    let a = map(r, size, glowSize * 2, 0.2, 0);
    fill(n.hue, 60, brightness * 0.5, a);
    ellipse(n.x, n.y, r * 2);
  }
  
  // Main node
  fill(n.hue, 50, brightness, 0.8);
  ellipse(n.x, n.y, size * 2);
  
  // Inner ring
  noFill();
  stroke(n.hue, 40, 80, 0.5);
  strokeWeight(1);
  ellipse(n.x, n.y, size * 1.2);
  
  // Core
  noStroke();
  fill(0, 0, 100, 0.9);
  ellipse(n.x, n.y, size * 0.4);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  setup();
}
</script>
</body>
</html>
