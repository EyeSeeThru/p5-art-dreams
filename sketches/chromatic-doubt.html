<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chromatic Doubt</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      overflow: hidden; 
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// CHROMATIC DOUBT
// Colors that compete for dominance, creating visual tension
// No particles. No waves. Just color fighting itself.

let orbs = [];
const ORB_COUNT = 15;
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 100);
  noStroke();
  
  for (let i = 0; i < ORB_COUNT; i++) {
    orbs.push({
      x: random(width),
      y: random(height),
      vx: random(-0.5, 0.5),
      vy: random(-0.5, 0.5),
      baseSize: random(40, 120),
      hue: random(360),
      hueVel: random(-15, 15),
      layer: floor(random(3)),
      phase: random(TWO_PI)
    });
  }
}

function draw() {
  background(0, 0, 0, 15); // Heavy trails
  
  t += 0.01;
  
  // Sort orbs by layer for proper depth
  orbs.sort((a, b) => a.layer - b.layer);
  
  for (let orb of orbs) {
    // Movement that's almost purposeful but not quite
    orb.x += orb.vx;
    orb.y += orb.vy;
    
    // Gentle steering
    let noiseVal = noise(orb.x * 0.001, orb.y * 0.001, t * 0.1);
    orb.vx += map(noiseVal, 0, 1, -0.02, 0.02);
    orb.vy += map(noiseVal, 0, 1, -0.02, 0.02);
    
    // Damping
    orb.vx *= 0.995;
    orb.vy *= 0.995;
    
    // Wrap with bias
    if (orb.x < -100) orb.x = width + 50;
    if (orb.x > width + 100) orb.x = -50;
    if (orb.y < -100) orb.y = height + 50;
    if (orb.y > height + 100) orb.y = -50;
    
    // Hue shift - colors that can't commit
    orb.hue = (orb.hue + orb.hueVel * 0.1) % 360;
    if (orb.hue < 0) orb.hue += 360;
    
    let pulse = sin(t * 2 + orb.phase) * 0.3 + 1;
    let size = orb.baseSize * pulse;
    
    // Draw conflict zones - where colors overlap, something else happens
    push();
    translate(orb.x, orb.y);
    
    // Core
    for (let ring = 0; ring < 4; ring++) {
      let ringSize = size * (1 - ring * 0.2);
      let ringHue = (orb.hue + ring * 30) % 360;
      let alpha = map(ring, 0, 3, 80, 30);
      
      fill(ringHue, 70, 90, alpha);
      
      // Not quite circular
      beginShape();
      for (let a = 0; a < TWO_PI; a += 0.1) {
        let r = ringSize * (1 + sin(a * 5 + t + orb.phase) * 0.1);
        vertex(cos(a) * r, sin(a) * r);
      }
      endShape(CLOSE);
    }
    
    // Color interference - the rainbow border
    let interferenceCount = 12;
    for (let i = 0; i < interferenceCount; i++) {
      let angle = TWO_PI * i / interferenceCount + t * 0.5;
      let dist = size * 1.2 + sin(t * 3 + i) * 10;
      let ix = cos(angle) * dist;
      let iy = sin(angle) * dist;
      
      // Each point is a different color
      let ihue = (orb.hue + i * 30 + t * 20) % 360;
      fill(ihue, 60, 80, 40);
      
      let dotSize = 8 + sin(t * 4 + i * 0.5) * 4;
      ellipse(ix, iy, dotSize);
    }
    
    // The doubt lines - connecting to neighbors
    strokeWeight(0.5);
    for (let other of orbs) {
      if (other !== orb) {
        let d = dist(orb.x, orb.y, other.x, other.y);
        if (d < 250 && d > 50) {
          // Line color is the average, but wrong
          let midHue = (orb.hue + other.hue + 180) % 360;
          let alpha = map(d, 50, 250, 20, 0);
          stroke(midHue, 50, 70, alpha);
          
          // Wavy line
          let midX = (orb.x + other.x) / 2;
          let midY = (orb.y + other.y) / 2;
          let wave = sin(t * 5 + dist * 0.01) * 20;
          
          line(orb.x, orb.y, midX + wave, midY + wave);
          line(midX + wave, midY + wave, other.x, other.y);
        }
      }
    }
    
    pop();
  }
  
  // Screen-wide color cast that shifts
  let castHue = (t * 5) % 360;
  loadPixels();
  for (let i = 0; i < pixels.length; i += 16) {
    // Subtle color injection
    let noiseVal = random();
    if (noiseVal < 0.01) {
      pixels[i] = (pixels[i] + castHue) % 255;
    }
  }
  updatePixels();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function mousePressed() {
  // Add energy to nearby orbs
  for (let orb of orbs) {
    let d = dist(mouseX, mouseY, orb.x, orb.y);
    if (d < 200) {
      let angle = atan2(orb.y - mouseY, orb.x - mouseX);
      orb.vx += cos(angle) * 2;
      orb.vy += sin(angle) * 2;
      orb.hue = (orb.hue + 60) % 360;
    }
  }
}
</script>
</body>
</html>
