<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>gyroid-surfaces</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #020104; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// GYROID SURFACES - Implicit surface visualization using ray marching
let time = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
}

function draw() {
  background(240, 20, 0.5, 0.02);
  
  time += 0.008;
  
  // Ray march the gyroid surface
  loadPixels();
  
  let camZ = time * 2;
  let scale = 0.15;
  
  for (let px = 0; px < width; px += 3) {
    for (let py = 0; py < height; py += 3) {
      // Ray direction
      let rx = (px - width / 2) / width;
      let ry = (py - height / 2) / height;
      
      let x = 0, y = 0, z = -5;
      let dx = rx * 0.2;
      let dy = ry * 0.2;
      let dz = 0.2;
      
      let hit = false;
      let totalDist = 0;
      
      for (let step = 0; step < 60; step++) {
        let g = gyroid(x * scale, y * scale, z * scale, time * 0.5);
        
        if (g < 0.05) {
          hit = true;
          break;
        }
        
        x += dx * g;
        y += dy * g;
        z += dz * g;
        totalDist += g;
        
        if (totalDist > 20) break;
      }
      
      if (hit) {
        let brightness = map(totalDist, 0, 15, 70, 20);
        let hue = map(x * scale + y * scale, -2, 2, 320, 360) % 360;
        let alpha = map(totalDist, 0, 10, 0.6, 0.2);
        
        noStroke();
        fill(hue, 50, brightness, alpha);
        rect(px, py, 3, 3);
      }
    }
  }
  
  // Draw surface points as glowing orbs
  drawGyroidPoints();
}

function gyroid(x, y, z, t) {
  return sin(x + t) * cos(y) + sin(y + t) * cos(z) + sin(z + t) * cos(x);
}

function drawGyroidPoints() {
  let scale = 0.12;
  let spacing = 1.5;
  
  for (let x = -8; x <= 8; x += spacing) {
    for (let y = -6; y <= 6; y += spacing) {
      for (let z = -4; z <= 4; z += spacing) {
        let g = gyroid(x * scale, y * scale, z * scale, time * 0.5);
        
        if (abs(g) < 0.15) {
          // Project 3D to 2D with perspective
          let zOff = z + 5 - time * 2;
          let perspective = 300 / (zOff + 10);
          let px = width / 2 + x * 50 * perspective;
          let py = height / 2 + y * 50 * perspective;
          
          if (px > 0 && px < width && py > 0 && py < height) {
            let hue = map(x + y + z, -15, 15, 320, 360) % 360;
            let size = perspective * 15;
            let alpha = map(abs(g), 0, 0.15, 0.5, 0.2);
            
            noStroke();
            for (let r = size * 2; r > size; r -= 3) {
              let a = map(r, size, size * 2, alpha, 0);
              fill(hue, 50, 30, a);
              ellipse(px, py, r);
            }
            
            fill(hue, 40, 60, alpha * 1.5);
            ellipse(px, py, size * 0.5);
          }
        }
      }
    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
