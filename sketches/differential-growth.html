<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Differential Growth</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #0a0a0a; 
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// Differential Growth - Organic line growth simulation
let points = [];
let maxPoints = 800;
let noiseScale = 0.003;
let growthRate = 0.8;
let colors;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colors = [
    color(255, 107, 107),
    color(255, 159, 67),
    color(255, 217, 61),
    color(168, 230, 255),
    color(167, 138, 255),
    color(255, 255, 255)
  ];
  
  // Initialize with a circle
  let centerX = width / 2;
  let centerY = height / 2;
  let radius = min(width, height) * 0.15;
  let numPoints = 12;
  
  for (let i = 0; i < numPoints; i++) {
    let angle = TWO_PI * i / numPoints;
    points.push({
      x: centerX + cos(angle) * radius,
      y: centerY + sin(angle) * radius,
      vx: 0,
      vy: 0,
      age: 0,
      color: colors[i % colors.length]
    });
  }
  
  background(10, 10, 15);
}

function draw() {
  // Fade effect
  noStroke();
  fill(10, 10, 15, 8);
  rect(0, 0, width, height);
  
  // Grow new points
  if (points.length < maxPoints) {
    growPoints();
  }
  
  // Move points with noise
  movePoints();
  
  // Draw connections
  drawConnections();
  
  // Draw points
  drawPoints();
  
  // Gentle glow
  drawGlow();
}

function growPoints() {
  let newPoints = [];
  
  for (let i = 0; i < points.length; i++) {
    let p = points[i];
    
    // Calculate distance to neighbors
    let prev = points[(i - 1 + points.length) % points.length];
    let next = points[(i + 1) % points.length];
    
    let dist1 = dist(p.x, p.y, prev.x, prev.y);
    let dist2 = dist(p.x, p.y, next.x, next.y);
    let avgDist = (dist1 + dist2) / 2;
    
    // Grow if too far apart
    if (avgDist > min(width, height) * 0.06) {
      let angle = atan2(next.y - prev.y, next.x - prev.x) + random(-0.5, 0.5);
      let noiseVal = noise(p.x * noiseScale, p.y * noiseScale, frameCount * 0.002);
      angle += map(noiseVal, 0, 1, -PI/2, PI/2);
      
      newPoints.push({
        x: p.x + cos(angle) * avgDist * 0.5,
        y: p.y + sin(angle) * avgDist * 0.5,
        vx: 0,
        vy: 0,
        age: 0,
        color: p.color
      });
    }
  }
  
  points.push(...newPoints);
}

function movePoints() {
  for (let p of points) {
    // Perlin noise movement
    let noiseX = noise(p.x * noiseScale, p.y * noiseScale, frameCount * 0.001);
    let noiseY = noise(p.x * noiseScale + 1000, p.y * noiseScale + 1000, frameCount * 0.001);
    
    let forceX = map(noiseX, 0, 1, -1, 1) * 0.5;
    let forceY = map(noiseY, 0, 1, -1, 1) * 0.5;
    
    // Boundary constraints
    let margin = 50;
    if (p.x < margin) forceX += 0.5;
    if (p.x > width - margin) forceX -= 0.5;
    if (p.y < margin) forceY += 0.5;
    if (p.y > height - margin) forceY -= 0.5;
    
    p.vx = p.vx * 0.95 + forceX * 0.05;
    p.vy = p.vy * 0.95 + forceY * 0.05;
    
    p.x += p.vx;
    p.y += p.vy;
    p.age++;
  }
}

function drawConnections() {
  for (let i = 0; i < points.length; i++) {
    let p = points[i];
    let next = points[(i + 1) % points.length];
    let d = dist(p.x, p.y, next.x, next.y);
    
    if (d < min(width, height) * 0.25) {
      let alpha = map(d, 0, min(width, height) * 0.25, 200, 20);
      let sw = map(d, 0, min(width, height) * 0.15, 3, 0.5);
      
      // Gradient line
      let steps = ceil(d / 5);
      for (let j = 0; j < steps; j++) {
        let t = j / steps;
        let x = lerp(p.x, next.x, t);
        let y = lerp(p.y, next.y, t);
        let c = lerpColor(p.color, next.color, t);
        
        noStroke();
        fill(red(c), green(c), blue(c), alpha * 0.5);
        ellipse(x, y, sw, sw);
      }
    }
  }
}

function drawPoints() {
  noStroke();
  for (let p of points) {
    let size = map(sin(p.age * 0.05), -1, 1, 3, 8);
    fill(red(p.color), green(p.color), blue(p.color), 220);
    ellipse(p.x, p.y, size, size);
  }
}

function drawGlow() {
  // Subtle radial glow from center
  let gradient = drawingContext.createRadialGradient(
    width/2, height/2, 0,
    width/2, height/2, min(width, height) * 0.6
  );
  gradient.addColorStop(0, 'rgba(30, 30, 50, 0.1)');
  gradient.addColorStop(1, 'rgba(10, 10, 15, 0)');
  
  drawingContext.fillStyle = gradient;
  rect(0, 0, width, height);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  background(10, 10, 15);
}
</script>
</body>
</html>
