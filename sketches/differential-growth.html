<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Differential Growth</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #0a0a0f; 
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// Differential Growth - Organic form evolution
let nodes = [];
let maxNodes = 800;
let minDistance = 8;
let maxDistance = 18;
let growthRate = 0.4;
let colors;
let time = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  
  // Initialize with a circular boundary
  colors = [
    color(320, 70, 90),   // Magenta
    color(280, 60, 85),   // Purple
    color(240, 80, 95),   // Blue
    color(180, 60, 80),   // Cyan
    color(140, 50, 70),   // Teal
  ];
  
  // Create initial seed nodes in a ring
  let seedRadius = min(width, height) * 0.15;
  let numSeeds = 12;
  for (let i = 0; i < numSeeds; i++) {
    let angle = TWO_PI * i / numSeeds;
    nodes.push({
      x: width/2 + cos(angle) * seedRadius,
      y: height/2 + sin(angle) * seedRadius,
      vx: 0,
      vy: 0,
      age: 0,
      hue: random(colors).hue()
    });
  }
}

function draw() {
  background(10, 8, 15, 0.08);
  
  // Update and grow
  if (nodes.length < maxNodes) {
    grow();
  }
  
  // Physics update
  for (let n of nodes) {
    // Slight wandering
    n.vx += random(-0.1, 0.1);
    n.vy += random(-0.1, 0.1);
    
    // Damping
    n.vx *= 0.98;
    n.vy *= 0.98;
    
    // Apply velocity
    n.x += n.vx;
    n.y += n.vy;
    
    // Boundary repulsion
    let margin = 50;
    if (n.x < margin) n.vx += 0.3;
    if (n.x > width - margin) n.vx -= 0.3;
    if (n.y < margin) n.vy += 0.3;
    if (n.y > height - margin) n.vy -= 0.3;
    
    n.age++;
  }
  
  // Draw connections
  strokeWeight(1.5);
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      let d = dist(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
      if (d < maxDistance) {
        let alpha = map(d, minDistance, maxDistance, 0.6, 0);
        stroke(nodes[i].hue, 70, 90, alpha);
        line(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
      }
    }
  }
  
  // Draw nodes
  noStroke();
  for (let n of nodes) {
    let size = map(sin(n.age * 0.05), -1, 1, 3, 6);
    fill(n.hue, 60, 100, 0.8);
    circle(n.x, n.y, size);
  }
  
  time += 0.01;
}

function grow() {
  // Try to add new nodes between nearby nodes
  let attempts = 10;
  for (let a = 0; a < attempts; a++) {
    if (nodes.length >= maxNodes) break;
    
    // Find two close nodes
    let i = floor(random(nodes.length));
    let j = -1;
    let closestDist = Infinity;
    
    for (let k = 0; k < nodes.length; k++) {
      if (k === i) continue;
      let d = dist(nodes[i].x, nodes[i].y, nodes[k].x, nodes[k].y);
      if (d > minDistance && d < maxDistance && d < closestDist) {
        closestDist = d;
        j = k;
      }
    }
    
    if (j !== -1 && random() < growthRate) {
      // Add node between them
      let newX = (nodes[i].x + nodes[j].x) / 2 + random(-3, 3);
      let newY = (nodes[i].y + nodes[j].y) / 2 + random(-3, 3);
      
      nodes.push({
        x: newX,
        y: newY,
        vx: (nodes[i].vx + nodes[j].vx) / 2,
        vy: (nodes[i].vy + nodes[j].vy) / 2,
        age: 0,
        hue: (nodes[i].hue + nodes[j].hue) / 2 + random(-10, 10)
      });
    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
