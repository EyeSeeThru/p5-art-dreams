<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inverse Squares — Gravitational Field Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// Inverse Squares — Gravitational field visualization
// Particles orbit and respond to inverse square law forces

let particles = [];
let numParticles = 400;
let attractors = [];
let time = 0;

class Attractor {
  constructor(x, y, mass, isPrimary = false) {
    this.pos = createVector(x, y);
    this.mass = mass;
    this.isPrimary = isPrimary;
    this.angle = random(TWO_PI);
  }
  
  display() {
    push();
    translate(this.pos.x, this.pos.y);
    
    // Glow effect
    for (let i = 5; i > 0; i--) {
      noStroke();
      let alpha = map(i, 5, 0, 10, 80);
      let size = this.mass * 0.5 + i * 8;
      fill(this.isPrimary ? color(255, 200, 100, alpha) : color(100, 200, 255, alpha));
      ellipse(0, 0, size, size);
    }
    
    // Core
    fill(this.isPrimary ? color(255, 240, 200) : color(150, 220, 255));
    noStroke();
    ellipse(0, 0, this.mass * 0.5, this.mass * 0.5);
    pop();
  }
}

class Particle {
  constructor() {
    this.reset();
  }
  
  reset() {
    let angle = random(TWO_PI);
    let dist = random(100, 350);
    this.pos = createVector(width/2 + cos(angle) * dist, height/2 + sin(angle) * dist);
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.prevPos = this.pos.copy();
    this.trail = [];
    this.maxTrail = 30;
    this.hue = random(360);
    this.size = random(2, 5);
    this.life = random(100, 300);
  }
  
  applyForce(force) {
    this.acc.add(force);
  }
  
  attract(target) {
    let force = p5.Vector.sub(target.pos, this.pos);
    let d = constrain(force.mag(), 20, 500);
    
    // Inverse square law: F = G * m1 * m2 / r^2
    let strength = (0.5 * target.mass) / (d * d);
    strength = constrain(strength, 0, 2);
    
    force.setMag(strength);
    this.applyForce(force);
  }
  
  update() {
    // Apply attraction to all attractors
    for (let attractor of attractors) {
      this.attract(attractor);
    }
    
    // Add slight turbulence
    let noiseScale = 0.01;
    let nx = (noise(this.pos.x * noiseScale, time * 0.5) - 0.5) * 0.1;
    let ny = (noise(this.pos.y * noiseScale, time * 0.5 + 100) - 0.5) * 0.1;
    this.acc.add(nx, ny);
    
    this.vel.add(this.acc);
    this.vel.limit(8);
    this.pos.add(this.vel);
    this.acc.mult(0);
    
    // Trail
    this.trail.push(this.pos.copy());
    if (this.trail.length > this.maxTrail) {
      this.trail.shift();
    }
    
    // Boundary wrap with reset
    if (this.pos.x < -50 || this.pos.x > width + 50 || 
        this.pos.y < -50 || this.pos.y > height + 50) {
      this.reset();
    }
    
    this.life--;
    if (this.life <= 0) this.reset();
  }
  
  display() {
    // Trail
    noFill();
    beginShape();
    for (let i = 0; i < this.trail.length; i++) {
      let alpha = map(i, 0, this.trail.length, 0, 150);
      let weight = map(i, 0, this.trail.length, 0.5, this.size);
      stroke(this.hue, 80, 80, alpha);
      strokeWeight(weight);
      vertex(this.trail[i].x, this.trail[i].y);
    }
    endShape();
    
    // Particle
    noStroke();
    fill(this.hue, 70, 90, 200);
    ellipse(this.pos.x, this.pos.y, this.size, this.size);
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 100);
  
  // Central massive attractor
  attractors.push(new Attractor(width/2, height/2, 80, true));
  
  // Smaller orbiting attractors
  for (let i = 0; i < 3; i++) {
    let angle = (TWO_PI / 3) * i;
    let dist = 200;
    let ax = width/2 + cos(angle) * dist;
    let ay = height/2 + sin(angle) * dist;
    attractors.push(new Attractor(ax, ay, 30));
  }
  
  // Create particles
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle());
  }
}

function draw() {
  // Dark background with slight trails
  background(0, 0, 0, 15);
  
  // Animate orbiting attractors
  let primary = attractors[0];
  for (let i = 1; i < attractors.length; i++) {
    let a = attractors[i];
    let angle = (TWO_PI / 3) * (i - 1) + time * 0.3;
    let dist = 180 + sin(time * 0.5 + i) * 30;
    a.pos.x = width/2 + cos(angle) * dist;
    a.pos.y = height/2 + sin(angle) * dist;
  }
  
  // Display attractors
  for (let attractor of attractors) {
    attractor.display();
  }
  
  // Update and display particles
  for (let particle of particles) {
    particle.update();
    particle.display();
  }
  
  // Draw field lines (subtle)
  drawFieldLines();
  
  time += 0.016;
}

function drawFieldLines() {
  stroke(280, 30, 50, 5);
  strokeWeight(0.5);
  
  let spacing = 40;
  for (let x = spacing/2; x < width; x += spacing) {
    for (let y = spacing/2; y < height; y += spacing) {
      let pos = createVector(x, y);
      let totalForce = createVector(0, 0);
      
      for (let attractor of attractors) {
        let force = p5.Vector.sub(attractor.pos, pos);
        let d = constrain(force.mag(), 30, 400);
        let strength = attractor.mass / (d * d);
        strength = constrain(strength, 0, 0.5);
        force.setMag(strength * 15);
        totalForce.add(force);
      }
      
      if (totalForce.mag() > 0.1) {
        let len = totalForce.mag() * 3;
        totalForce.limit(len);
        line(x, y, x + totalForce.x, y + totalForce.y);
      }
    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  attractors[0].pos.set(width/2, height/2);
}
</script>
</body>
</html>
