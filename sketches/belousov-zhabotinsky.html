<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Belousov-Zhabotinsky â€” Chemical Oscillations</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #0a0a0f; 
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// Belousov-Zhabotinsky Chemical Oscillator
// Creates beautiful spiral wave patterns through reaction-diffusion dynamics

let grid;
let next;
let cols, rows;
let scale = 4;

// Gray-Scott reaction-diffusion parameters (tuned for vibrant spirals)
let feed = 0.037;
let kill = 0.06;

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  
  cols = floor(width / scale);
  rows = floor(height / scale);
  
  grid = new Array(cols).fill(0).map(() => new Array(rows).fill(0).map(() => ({ a: 1, b: 0 })));
  next = new Array(cols).fill(0).map(() => new Array(rows).fill(0).map(() => ({ a: 1, b: 0 })));
  
  // Seed with random b values (more aggressive)
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      if (random() < 0.15) {
        grid[i][j].b = 1;
        grid[i][j].a = 0;
      }
    }
  }
  
  // Add seed clusters (larger and more)
  for (let n = 0; n < 12; n++) {
    let cx = floor(random(cols * 0.2, cols * 0.8));
    let cy = floor(random(rows * 0.2, rows * 0.8));
    let r = floor(random(10, 25));
    
    for (let i = cx - r; i < cx + r; i++) {
      for (let j = cy - r; j < cy + r; j++) {
        if (i >= 0 && i < cols && j >= 0 && j < rows) {
          let d = dist(i, j, cx, cy);
          if (d < r) {
            grid[i][j].b = 1;
            grid[i][j].a = 0;
          }
        }
      }
    }
  }
}

function draw() {
  background(10, 10, 15);
  
  // Run more simulation steps per frame for faster evolution
  for (let step = 0; step < 20; step++) {
    simulate();
  }
  
  // Render the grid
  loadPixels();
  
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let a = grid[i][j].a;
      let b = grid[i][j].b;
      
      // Color based on b concentration
      let c;
      if (b < 0.1) {
        c = color(10 + b * 200, 10 + b * 100, 30 + b * 400);
      } else if (b < 0.25) {
        c = color(60 + (b - 0.1) * 800, 30 + (b - 0.1) * 200, 150 + (b - 0.1) * 400);
      } else if (b < 0.5) {
        c = color(180 + (b - 0.25) * 300, 60 + (b - 0.25) * 300, 150 - (b - 0.25) * 200);
      } else {
        c = color(255, 140 + (b - 0.5) * 200, 50 + (b - 0.5) * 100);
      }
      
      // Draw scaled pixel
      for (let sx = 0; sx < scale; sx++) {
        for (let sy = 0; sy < scale; sy++) {
          let px = i * scale + sx;
          let py = j * scale + sy;
          if (px < width && py < height) {
            let idx = 4 * (py * width + px);
            pixels[idx] = red(c);
            pixels[idx + 1] = green(c);
            pixels[idx + 2] = blue(c);
            pixels[idx + 3] = 255;
          }
        }
      }
    }
  }
  
  updatePixels();
  
  // Vignette
  noStroke();
  for (let i = 0; i < 30; i++) {
    fill(0, map(i, 0, 30, 40, 0));
    rect(0, 0, width, height);
  }
}

function simulate() {
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let a = grid[i][j].a;
      let b = grid[i][j].b;
      
      // Laplacian (diffusion)
      let laplaceA = 0;
      let laplaceB = 0;
      
      // 3x3 convolution with wrap-around (toroidal boundary)
      for (let di = -1; di <= 1; di++) {
        for (let dj = -1; dj <= 1; dj++) {
          let ni = (i + di + cols) % cols;
          let nj = (j + dj + rows) % rows;
          
          let weight = 1;
          if (di === 0 && dj === 0) weight = -1;
          else if (abs(di) + abs(dj) === 1) weight = 0.2;
          else weight = 0.05;
          
          laplaceA += grid[ni][nj].a * weight;
          laplaceB += grid[ni][nj].b * weight;
        }
      }
      
      // Gray-Scott reaction-diffusion equations
      let ab2 = a * b * b;
      
      next[i][j].a = a + (0.21 * laplaceA - ab2 + feed * (1 - a));
      next[i][j].b = b + (0.21 * laplaceB + ab2 - (kill + feed) * b);
      
      // Constrain values
      next[i][j].a = constrain(next[i][j].a, 0, 1);
      next[i][j].b = constrain(next[i][j].b, 0, 1);
    }
  }
  
  // Swap grids
  let temp = grid;
  grid = next;
  next = temp;
}

function windowResized() {
  setup();
}

// Click to add new seeds
function mousePressed() {
  let i = floor(mouseX / scale);
  let j = floor(mouseY / scale);
  let r = 10;
  
  for (let di = -r; di <= r; di++) {
    for (let dj = -r; dj <= r; dj++) {
      let ni = (i + di + cols) % cols;
      let nj = (j + dj + rows) % rows;
      if (dist(di, dj, 0, 0) < r) {
        grid[ni][nj].b = 1;
        grid[ni][nj].a = 0;
      }
    }
  }
}
</script>
</body>
</html>
