<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>temporal-fractures</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #040406; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// TEMPORAL FRACTURES - Shapes that fracture along time-evolving patterns
let shapes = [];
let time = 0;
const SHAPE_COUNT = 6;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  
  for (let i = 0; i < SHAPE_COUNT; i++) {
    shapes.push(createShape(i));
  }
}

function createShape(index) {
  let cx = random(width * 0.2, width * 0.8);
  let cy = random(height * 0.2, height * 0.8);
  let baseRadius = random(80, 180);
  let sides = floor(random(5, 10));
  
  return {
    cx, cy, baseRadius, sides,
    rotation: random(TWO_PI),
    rotSpeed: random(-0.005, 0.005),
    vertices: generateVertices(cx, cy, baseRadius, sides, 0),
    hue: random(320, 360),
    fracturePhase: random(TWO_PI),
    fractureSpeed: random(0.01, 0.02),
    thickness: random(2, 5)
  };
}

function generateVertices(cx, cy, r, sides, timeOffset) {
  let verts = [];
  for (let i = 0; i < sides; i++) {
    let angle = map(i, 0, sides, 0, TWO_PI);
    // Add noise distortion
    let noiseVal = noise(cos(angle) * 2 + timeOffset, sin(angle) * 2);
    let r2 = r * (0.7 + noiseVal * 0.6);
    verts.push({
      x: cx + cos(angle) * r2,
      y: cy + sin(angle) * r2,
      angle: angle
    });
  }
  return verts;
}

function draw() {
  background(240, 30, 2, 0.05);
  
  time += 0.02;
  
  for (let s of shapes) {
    s.rotation += s.rotSpeed;
    s.vertices = generateVertices(s.cx, s.cy, s.baseRadius, s.sides, time + s.fracturePhase);
    drawShape(s);
    drawFractures(s);
  }
  
  // Inter-shape connections
  for (let i = 0; i < shapes.length; i++) {
    for (let j = i + 1; j < shapes.length; j++) {
      let d = dist(shapes[i].cx, shapes[i].cy, shapes[j].cx, shapes[j].cy);
      if (d < 250) {
        let alpha = map(d, 0, 250, 0.12, 0);
        stroke((shapes[i].hue + shapes[j].hue) / 2, 40, 60, alpha);
        strokeWeight(1);
        line(shapes[i].cx, shapes[i].cy, shapes[j].cx, shapes[j].cy);
      }
    }
  }
}

function drawShape(s) {
  noFill();
  
  // Multiple outline layers
  for (let layer = 2; layer >= 0; layer--) {
    let alpha = 0.3 - layer * 0.08;
    let weight = s.thickness + layer * 1.5;
    
    stroke(s.hue + layer * 5, 60, 80, alpha);
    strokeWeight(weight);
    
    beginShape();
    for (let v of s.vertices) {
      // Offset vertex based on layer
      let offset = layer * 8;
      let nx = v.x + cos(v.angle + s.rotation) * offset;
      let ny = v.y + sin(v.angle + s.rotation) * offset;
      vertex(nx, ny);
    }
    endShape(CLOSE);
  }
  
  // Fill with gradient
  noStroke();
  for (let i = 0; i < s.vertices.length; i++) {
    let v = s.vertices[i];
    let nextV = s.vertices[(i + 1) % s.vertices.length];
    
    // Triangle fan from center
    fill(s.hue, 30, 40, 0.08);
    triangle(s.cx, s.cy, v.x, v.y, nextV.x, nextV.y);
  }
}

function drawFractures(s) {
  let fractureTime = time * 2 + s.fracturePhase;
  let fractureCount = floor(map(sin(fractureTime), -1, 1, 3, 8));
  
  for (let i = 0; i < fractureCount; i++) {
    let startIdx = floor(random(s.vertices.length));
    let startV = s.vertices[startIdx];
    let endIdx = floor(random(s.vertices.length));
    let endV = s.vertices[endIdx];
    
    if (startIdx !== endIdx) {
      // Calculate midpoint with noise
      let midX = (startV.x + endV.x) / 2;
      let midY = (startV.y + endV.y) / 2;
      
      let noiseOffset = noise(i * 0.5 + fractureTime) * 40 - 20;
      midX += cos(fractureTime + i) * noiseOffset;
      midY += sin(fractureTime + i) * noiseOffset;
      
      // Draw fracture line with glow
      let alpha = 0.4 + sin(fractureTime * 2 + i) * 0.2;
      
      // Glow
      stroke(s.hue + 20, 50, 80, alpha * 0.3);
      strokeWeight(6);
      line(startV.x, startV.y, midX, midY);
      line(midX, midY, endV.x, endV.y);
      
      // Core
      stroke(s.hue, 60, 100, alpha);
      strokeWeight(1.5);
      line(startV.x, startV.y, midX, midY);
      line(midX, midY, endV.x, endV.y);
    }
  }
  
  // Pulsing core
  let pulse = 0.5 + sin(time * 3 + s.fracturePhase) * 0.5;
  fill(s.hue, 40, 60, pulse * 0.15);
  noStroke();
  ellipse(s.cx, s.cy, s.baseRadius * 0.4);
  
  fill(s.hue + 30, 30, 80, pulse * 0.4);
  ellipse(s.cx, s.cy, s.baseRadius * 0.15);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  // Reposition shapes
  for (let s of shapes) {
    s.cx = random(width * 0.2, width * 0.8);
    s.cy = random(height * 0.2, height * 0.8);
    s.vertices = generateVertices(s.cx, s.cy, s.baseRadius, s.sides, time);
  }
}
</script>
</body>
</html>
