<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neural Bloom</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      overflow: hidden; 
      background: #080808;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// NEURAL BLOOM - Organic neural network visualization
// Dendrites reaching through dark space,
// firing signals in slow, deliberate pulses.
// Like watching thoughts form in a silicon mind.

let particles = [];
const NUM_PARTICLES = 300;
let t = 0;
let connectionThreshold = 80;

class Neuron {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = createVector(random(-0.3, 0.3), random(-0.3, 0.3));
    this.acc = createVector(0, 0);
    this.maxSpeed = random(0.5, 1.5);
    this.maxForce = 0.02;
    this.radius = random(2, 5);
    this.phase = random(TWO_PI);
    this.firingRate = random(0.01, 0.03);
    this.isFiring = false;
    this.fireTimer = 0;
    this.color = random() > 0.7 ? 
      color(random(180, 260), random(70, 90), random(80, 100)) : // cyan/blue
      color(random(280, 320), random(60, 80), random(70, 90));   // purple/magenta
    this.connections = [];
  }
  
  update() {
    // Perlin noise flow field influence
    let angle = noise(this.pos.x * 0.002, this.pos.y * 0.002, t * 0.3) * TWO_PI * 2;
    let flow = p5.Vector.fromAngle(angle);
    flow.mult(0.05);
    this.applyForce(flow);
    
    // Gentle attraction to center
    let center = createVector(width/2, height/2);
    let toCenter = p5.Vector.sub(center, this.pos);
    let dist = toCenter.mag();
    toCenter.normalize();
    toCenter.mult(0.02);
    this.applyForce(toCenter);
    
    // Boundary repulsion
    let margin = 50;
    if (this.pos.x < margin) this.applyForce(createVector(0.1, 0));
    if (this.pos.x > width - margin) this.applyForce(createVector(-0.1, 0));
    if (this.pos.y < margin) this.applyForce(createVector(0, 0.1));
    if (this.pos.y > height - margin) this.applyForce(createVector(0, -0.1));
    
    // Update physics
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);
    
    // Firing mechanism
    if (!this.isFiring && random() < this.firingRate) {
      this.isFiring = true;
      this.fireTimer = random(30, 80);
    }
    
    if (this.isFiring) {
      this.fireTimer--;
      if (this.fireTimer <= 0) {
        this.isFiring = false;
      }
    }
    
    this.phase += 0.02;
  }
  
  applyForce(force) {
    this.acc.add(force);
  }
  
  display() {
    let pulse = sin(this.phase) * 0.3 + 1;
    let baseAlpha = this.isFiring ? 255 : 150;
    
    // Glow effect
    noStroke();
    for (let i = 3; i > 0; i--) {
      let alpha = baseAlpha / (i * i) * 0.5;
      let size = this.radius * pulse * (1 + i * 0.5);
      let c = color(red(this.color), green(this.color), blue(this.color), alpha);
      fill(c);
      ellipse(this.pos.x, this.pos.y, size, size);
    }
    
    // Core
    fill(this.isFiring ? 255 : red(this.color), 
         this.isFiring ? 255 : green(this.color), 
         this.isFiring ? 255 : blue(this.color), 
         baseAlpha);
    ellipse(this.pos.x, this.pos.y, this.radius * pulse, this.radius * pulse);
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  
  for (let i = 0; i < NUM_PARTICLES; i++) {
    particles.push(new Neuron());
  }
}

function draw() {
  // Deep dark background with subtle trail
  background(8, 8, 12, 30);
  
  t += 0.01;
  
  // Update and draw particles
  for (let p of particles) {
    p.update();
    p.display();
  }
  
  // Draw connections
  strokeWeight(0.5);
  for (let i = 0; i < particles.length; i++) {
    let p1 = particles[i];
    
    // Connect to nearby neurons
    for (let j = i + 1; j < particles.length; j++) {
      let p2 = particles[j];
      let d = p1.pos.dist(p2.pos);
      
      if (d < connectionThreshold) {
        let alpha = map(d, 0, connectionThreshold, 80, 0);
        
        // Connection color based on firing state
        if (p1.isFiring || p2.isFiring) {
          stroke(200, 220, 255, alpha);
          // Signal pulse along connection
          if (random() < 0.02) {
            drawPulse(p1.pos, p2.pos);
          }
        } else {
          stroke(red(p1.color), green(p1.color), blue(p1.color), alpha * 0.3);
        }
        
        line(p1.pos.x, p1.pos.y, p2.pos.x, p2.pos.y);
      }
    }
  }
  
  // Add subtle ambient particles
  if (random() < 0.1) {
    let x = random(width);
    let y = random(height);
    noStroke();
    fill(200, 220, 255, random(20, 50));
    ellipse(x, y, random(1, 3));
  }
  
  // Vignette
  drawVignette();
  
  // Noise grain
  loadPixels();
  for (let i = 0; i < pixels.length; i += 25) {
    let grain = random(-3, 3);
    pixels[i] = constrain(pixels[i] + grain, 0, 255);
    pixels[i+1] = constrain(pixels[i+1] + grain, 0, 255);
    pixels[i+2] = constrain(pixels[i+2] + grain, 0, 255);
  }
  updatePixels();
}

function drawPulse(start, end) {
  let steps = 20;
  for (let i = 0; i < steps; i++) {
    let amt = (frameCount % 30) / 30;
    let x = lerp(start.x, end.x, amt);
    let y = lerp(start.y, end.y, amt);
    noStroke();
    fill(255, 255, 255, 100 - i * 4);
    ellipse(x, y, 2);
  }
}

function drawVignette() {
  let gradient = drawingContext.createRadialGradient(
    width/2, height/2, 0,
    width/2, height/2, width * 0.7
  );
  gradient.addColorStop(0, 'rgba(0,0,0,0)');
  gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
  drawingContext.fillStyle = gradient;
  drawingContext.fillRect(0, 0, width, height);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function mousePressed() {
  // Trigger firing cascade from click point
  for (let p of particles) {
    let d = dist(mouseX, mouseY, p.pos.x, p.pos.y);
    if (d < 150) {
      p.isFiring = true;
      p.fireTimer = random(40, 100);
    }
  }
}
</script>
</body>
</html>
