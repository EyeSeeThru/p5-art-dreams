<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Moire Weave</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background: #080808; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// Moire Weave - Interference pattern visualization
// Overlapping oscillating grids creating complex moire patterns

let t = 0;
const GRID_SIZE = 40;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
}

function draw() {
  background(0, 0, 4);
  
  let cellW = width / GRID_SIZE;
  let cellH = height / GRID_SIZE;
  
  // First grid - horizontal oscillation
  drawGrid(GRID_SIZE, GRID_SIZE, t * 0.5, 0, 'horizontal');
  
  // Second grid - vertical oscillation with phase offset
  drawGrid(GRID_SIZE, GRID_SIZE, 0, t * 0.7, 'vertical');
  
  // Central interference highlight
  translate(width / 2, height / 2);
  noStroke();
  for (let r = 100; r > 0; r -= 10) {
    fill(0, 0, 100, 0.015);
    ellipse(0, 0, r * 2);
  }
  
  t += 0.03;
}

function drawGrid(cols, rows, offsetX, offsetY, orientation) {
  let cellW = width / cols;
  let cellH = height / rows;
  
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let x = i * cellW;
      let y = j * cellH;
      
      // Calculate oscillation
      let oscX = sin(i * 0.3 + t + offsetX) * cellW * 0.4;
      let oscY = sin(j * 0.3 + t * 1.2 + offsetY) * cellH * 0.4;
      
      let cx = x + cellW / 2 + oscX;
      let cy = y + cellH / 2 + oscY;
      
      // Distance from center affects size and color
      let d = dist(cx, cy, width / 2, height / 2);
      let maxD = dist(0, 0, width / 2, height / 2);
      
      let size = map(d, 0, maxD, cellW * 0.4, cellW * 0.15);
      let hue = map(d, 0, maxD, 0, 280);
      let sat = 70;
      let bri = map(sin(i * 0.2 + j * 0.2 + t), -1, 1, 20, 80);
      let alpha = map(d, 0, maxD, 0.6, 0.15);
      
      // Color variation based on orientation
      if (orientation === 'vertical') {
        hue = (hue + 180) % 360;
        alpha *= 0.7;
      }
      
      noStroke();
      fill(hue, sat, bri, alpha);
      
      // Draw different shapes based on orientation
      if (orientation === 'horizontal') {
        rectMode(CENTER);
        rect(cx, cy, size, size * 1.5);
      } else {
        ellipse(cx, cy, size * 1.5, size);
      }
    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
