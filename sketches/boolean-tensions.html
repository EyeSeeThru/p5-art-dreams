<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boolean Tensions — p5 Art Dreams</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #0a0a0a; 
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// Boolean Tensions — Boolean shape operations as artistic expression
// Intersections, exclusions, unions as visual tension
// Black + red palette

let shapes = [];
let time = 0;
let numShapes = 8;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  
  // Create initial shapes
  for (let i = 0; i < numShapes; i++) {
    shapes.push(createShape(i));
  }
}

function createShape(idx) {
  let types = ['circle', 'rect', 'triangle'];
  return {
    type: types[idx % 3],
    x: random(width * 0.2, width * 0.8),
    y: random(height * 0.2, height * 0.8),
    size: random(80, 200),
    vx: random(-0.8, 0.8),
    vy: random(-0.8, 0.8),
    rotation: random(TWO_PI),
    rotSpeed: random(-0.01, 0.01),
    hue: random() > 0.7 ? random(0, 20) : random(340, 360), // Red variations
    op: floor(random(3)) // 0=union, 1=intersection, 2=difference
  };
}

function draw() {
  background(0, 0, 4, 0.2); // Trails
  
  time += 0.01;
  
  // Draw intersection results (the "tension" zones)
  blendMode(ADD);
  
  // Create visual intersections through layered drawing
  for (let i = 0; i < shapes.length; i++) {
    let s = shapes[i];
    
    // Move
    s.x += s.vx;
    s.y += s.vy;
    s.rotation += s.rotSpeed;
    
    // Bounce
    if (s.x < 50 || s.x > width - 50) s.vx *= -1;
    if (s.y < 50 || s.y > height - 50) s.vy *= -1;
    
    push();
    translate(s.x, s.y);
    rotate(s.rotation);
    
    // Draw shape
    noFill();
    strokeWeight(2);
    stroke(s.hue, 80, 90, 0.5);
    
    if (s.type === 'circle') {
      ellipse(0, 0, s.size);
      // Inner echo
      ellipse(0, 0, s.size * 0.6);
    } else if (s.type === 'rect') {
      rectMode(CENTER);
      rect(0, 0, s.size, s.size * 0.7);
      rect(0, 0, s.size * 0.5, s.size * 0.35);
    } else {
      let r = s.size * 0.5;
      triangle(0, -r, -r, r, r, r);
      triangle(0, -r * 0.5, -r * 0.5, r * 0.5, r * 0.5, r * 0.5);
    }
    
    pop();
  }
  
  // Draw tension lines between overlapping shapes
  strokeWeight(1);
  for (let i = 0; i < shapes.length; i++) {
    for (let j = i + 1; j < shapes.length; j++) {
      let d = dist(shapes[i].x, shapes[i].y, shapes[j].x, shapes[j].y);
      if (d < 200) {
        let alpha = map(d, 0, 200, 0.4, 0);
        stroke(355, 90, 100, alpha);
        line(shapes[i].x, shapes[i].y, shapes[j].x, shapes[j].y);
      }
    }
  }
  
  blendMode(BLEND);
  
  // Central tension point
  let cx = width / 2 + sin(time) * 50;
  let cy = height / 2 + cos(time * 0.7) * 30;
  
  noFill();
  strokeWeight(3);
  stroke(355, 100, 100, 0.8);
  
  for (let i = 0; i < 5; i++) {
    let r = 30 + i * 20 + sin(time * 2 + i) * 10;
    ellipse(cx, cy, r, r * 0.8);
  }
  
  // Click to spawn new shape
  if (mouseIsPressed && frameCount % 10 === 0) {
    shapes.push(createShape(shapes.length));
    if (shapes.length > 15) shapes.shift();
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function mousePressed() {
  // Add burst of energy
  for (let s of shapes) {
    let d = dist(mouseX, mouseY, s.x, s.y);
    if (d < 200) {
      let angle = atan2(s.y - mouseY, s.x - mouseX);
      s.vx += cos(angle) * 2;
      s.vy += sin(angle) * 2;
    }
  }
}
</script>
</body>
</html>
