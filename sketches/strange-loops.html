<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Strange Loops</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      overflow: hidden; 
      background: #0a0a0f;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// Strange Loops - Recursive Impossible Geometries
// Inspired by M.C. Escher's work

let t = 0;
let zoom = 1;
let maxDepth = 6;
let rotationOffset = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  noStroke();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  background(240, 30, 5, 0.15);
  
  let cx = width / 2;
  let cy = height / 2;
  
  // Slow zoom oscillation
  zoom = 0.3 + 0.7 * (0.5 + 0.5 * sin(t * 0.15));
  rotationOffset = t * 0.2;
  
  // Draw recursive impossible geometry
  push();
  translate(cx, cy);
  scale(zoom);
  
  // Main recursive structure
  drawStrangeLoop(0, 0, min(width, height) * 0.4, 0);
  
  pop();
  
  t += 0.02;
}

function drawStrangeLoop(x, y, size, depth) {
  if (depth >= maxDepth || size < 5) return;
  
  let hue = (depth * 40 + t * 10) % 360;
  let bright = map(depth, 0, maxDepth, 90, 60);
  let alpha = map(depth, 0, maxDepth, 0.9, 0.4);
  
  // Rotate based on depth and time
  let angle = (depth % 2 === 0 ? 1 : -1) * (PI / 6) * sin(t * 0.3 + depth * 0.5);
  angle += rotationOffset * (depth + 1) * 0.1;
  
  push();
  rotate(angle);
  
  // Draw interlocking geometric shapes
  let sides = 6;
  
  for (let i = 0; i < sides; i++) {
    let a = TWO_PI / sides * i + t * 0.1 * (depth + 1);
    let px = cos(a) * size * 0.5;
    let py = sin(a) * size * 0.5;
    
    fill((hue + i * 20) % 360, 70, bright, alpha);
    
    // Alternating shapes based on depth
    if (depth % 3 === 0) {
      drawHexagon(px, py, size * 0.4);
    } else if (depth % 3 === 1) {
      drawTriangle(px, py, size * 0.35);
    } else {
      drawSquare(px, py, size * 0.35);
    }
  }
  
  // Connect vertices with curved lines
  noFill();
  stroke(hue, 60, bright, alpha * 0.6);
  strokeWeight(size * 0.02);
  
  for (let i = 0; i < sides; i++) {
    let a1 = TWO_PI / sides * i + t * 0.1 * (depth + 1);
    let a2 = TWO_PI / sides * ((i + 2) % sides) + t * 0.1 * (depth + 1);
    let x1 = cos(a1) * size * 0.5;
    let y1 = sin(a1) * size * 0.5;
    let x2 = cos(a2) * size * 0.5;
    let y2 = sin(a2) * size * 0.5;
    
    bezier(x1, y1, 
            x1 * 1.5, y1 * 1.5, 
            x2 * 1.5, y2 * 1.5, 
            x2, y2);
  }
  
  noStroke();
  
  // Recursive call with offset
  let nextSize = size * 0.45;
  
  for (let i = 0; i < 3; i++) {
    let a = TWO_PI / 3 * i + depth * 0.3 + t * 0.15;
    let nx = cos(a) * size * 0.6;
    let ny = sin(a) * size * 0.6;
    
    drawStrangeLoop(nx, ny, nextSize, depth + 1);
  }
  
  pop();
}

function drawHexagon(x, y, r) {
  beginShape();
  for (let i = 0; i < 6; i++) {
    let a = TWO_PI / 6 * i + t * 0.2;
    vertex(x + cos(a) * r, y + sin(a) * r);
  }
  endShape(CLOSE);
}

function drawTriangle(x, y, r) {
  beginShape();
  for (let i = 0; i < 3; i++) {
    let a = TWO_PI / 3 * i + t * 0.25 + PI/6;
    vertex(x + cos(a) * r, y + sin(a) * r);
  }
  endShape(CLOSE);
}

function drawSquare(x, y, r) {
  push();
  translate(x, y);
  rotate(t * 0.3);
  rectMode(CENTER);
  rect(0, 0, r * 1.4, r * 1.4, r * 0.1);
  pop();
}
</script>
</body>
</html>
