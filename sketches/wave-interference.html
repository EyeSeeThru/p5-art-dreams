<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wave Interference — p5.js Art</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #0a0a0f; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// Wave Interference — Constructive and destructive wave patterns
// Exploration of superposition principle with animated wave sources

const sources = [];
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  
  // Initialize wave sources at random positions
  for (let i = 0; i < 5; i++) {
    sources.push({
      x: random(width * 0.2, width * 0.8),
      y: random(height * 0.2, height * 0.8),
      freq: random(0.02, 0.05),
      amp: random(80, 150),
      phase: random(TWO_PI),
      speed: random(0.8, 1.5)
    });
  }
}

function draw() {
  background(10, 10, 15);
  
  loadPixels();
  
  // Calculate wave interference for each pixel
  for (let x = 0; x < width; x += 2) {
    for (let y = 0; y < height; y += 2) {
      let totalWave = 0;
      
      for (let s of sources) {
        let d = dist(x, y, s.x, s.y);
        let wave = sin(d * s.freq - t * s.speed + s.phase) * s.amp;
        wave *= exp(-d * 0.003); // decay with distance
        totalWave += wave;
      }
      
      // Map wave amplitude to color
      let normalized = map(totalWave, -300, 300, 0, 1);
      
      // Interference color palette
      let r, g, b;
      
      // Deep blues and cyans for negative (destructive)
      // Warm oranges and magentas for positive (constructive)
      if (totalWave > 0) {
        let n = constrain(totalWave / 200, 0, 1);
        r = lerp(255, 30, n);
        g = lerp(120, 20, n);
        b = lerp(80, 50, n);
      } else {
        let n = constrain(-totalWave / 200, 0, 1);
        r = lerp(20, 80, n);
        g = lerp(40, 150, n);
        b = lerp(60, 220, n);
      }
      
      // Add glow effect
      let glow = sin(normalized * PI) * 50;
      
      // Set pixels (with downsampling for performance)
      for (let dx = 0; dx < 2 && x + dx < width; dx++) {
        for (let dy = 0; dy < 2 && y + dy < height; dy++) {
          let idx = 4 * ((y + dy) * width + (x + dx));
          pixels[idx] = constrain(r + glow * 0.3, 0, 255);
          pixels[idx + 1] = constrain(g + glow * 0.2, 0, 255);
          pixels[idx + 2] = constrain(b + glow * 0.1, 0, 255);
          pixels[idx + 3] = 255;
        }
      }
    }
  }
  
  updatePixels();
  
  // Draw source points with pulsing glow
  for (let s of sources) {
    let pulse = sin(t * 0.1 + s.phase) * 0.3 + 0.7;
    
    // Outer glow
    noStroke();
    for (let r = 60; r > 0; r -= 10) {
      let alpha = map(r, 0, 60, 80, 0) * pulse;
      fill(255, 200, 150, alpha);
      ellipse(s.x, s.y, r, r);
    }
    
    // Core
    fill(255, 240, 220);
    ellipse(s.x, s.y, 12 * pulse, 12 * pulse);
  }
  
  t += 0.05;
  
  // Subtle vignette
  noStroke();
  for (let i = 0; i < 50; i++) {
    let alpha = map(i, 0, 50, 0, 100);
    fill(0, alpha);
    rect(0, 0, width, i);
    rect(0, height - i, width, i);
    rect(0, 0, i, height);
    rect(width - i, 0, i, height);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  // Reposition sources on resize
  setup();
}

function mousePressed() {
  // Add new wave source on click
  if (sources.length < 12) {
    sources.push({
      x: mouseX,
      y: mouseY,
      freq: random(0.02, 0.05),
      amp: random(80, 150),
      phase: random(TWO_PI),
      speed: random(0.8, 1.5)
    });
  }
}
</script>
</body>
</html>
