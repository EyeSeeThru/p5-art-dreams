<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fermat Spiral</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// Fermat Spiral - Golden spiral with harmonic oscillation
// Based on the golden angle (137.508Â°) creating phyllotaxis patterns

let points = [];
let goldenAngle = 137.508;
let numPoints = 800;
let time = 0;
let palette;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 100);
  palette = [
    color(45, 90, 100),   // Gold
    color(30, 85, 100),   // Amber
    color(15, 80, 100),   // Orange
    color(0, 0, 100),     // White
    color(280, 60, 80),   // Purple
    color(320, 70, 90),   // Magenta
  ];
  
  // Generate spiral points
  for (let i = 0; i < numPoints; i++) {
    let angle = i * goldenAngle;
    let radius = 4 * sqrt(i);
    points.push({
      baseAngle: angle,
      baseRadius: radius,
      hue: (i * 0.5) % 360
    });
  }
}

function draw() {
  background(0, 0, 5, 15);
  translate(width / 2, height / 2);
  
  let maxRadius = min(width, height) * 0.45;
  
  for (let i = 0; i < points.length; i++) {
    let p = points[i];
    
    // Harmonic oscillation
    let oscillation = sin(time * 2 + i * 0.02) * 0.3;
    let radiusOsc = sin(time * 1.5 + i * 0.01) * 20;
    
    let radius = p.baseRadius + radiusOsc;
    radius = min(radius, maxRadius);
    
    // Apply oscillation to angle
    let angle = p.baseAngle + oscillation * 0.1;
    
    // Convert polar to cartesian
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    
    // Size varies with position and time
    let size = map(i, 0, numPoints, 2, 12);
    size *= (0.8 + 0.4 * sin(time + i * 0.05));
    
    // Color based on radius and time
    let hue = (p.hue + time * 10) % 360;
    let sat = map(radius, 0, maxRadius, 80, 40);
    let bri = map(radius, 0, maxRadius, 100, 40);
    let alpha = map(i, 0, numPoints, 90, 50);
    
    // Outer glow
    noStroke();
    fill(hue, sat * 0.5, bri, alpha * 0.3);
    ellipse(x, y, size * 3, size * 3);
    
    // Main point
    fill(hue, sat, bri, alpha);
    ellipse(x, y, size, size);
    
    // Inner highlight
    fill(0, 0, 100, alpha * 0.8);
    ellipse(x, y, size * 0.4, size * 0.4);
  }
  
  // Connect nearby points with lines
  stroke(45, 60, 100, 10);
  strokeWeight(0.5);
  for (let i = 0; i < points.length - 1; i++) {
    let p1 = points[i];
    let r1 = min(p1.baseRadius + sin(time * 1.5 + i * 0.01) * 20, maxRadius);
    let a1 = p1.baseAngle + sin(time * 2 + i * 0.02) * 0.03;
    let x1 = r1 * cos(a1);
    let y1 = r1 * sin(a1);
    
    for (let j = i + 1; j < min(i + 30, points.length); j++) {
      let p2 = points[j];
      let r2 = min(p2.baseRadius + sin(time * 1.5 + j * 0.01) * 20, maxRadius);
      let a2 = p2.baseAngle + sin(time * 2 + j * 0.02) * 0.03;
      let x2 = r2 * cos(a2);
      let y2 = r2 * sin(a2);
      
      let d = dist(x1, y1, x2, y2);
      if (d < 30) {
        let alpha = map(d, 0, 30, 15, 0);
        stroke(45, 60, 100, alpha);
        line(x1, y1, x2, y2);
      }
    }
  }
  
  time += 0.02;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
