<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>phase-portraits</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #030304; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// PHASE PORTRAITS - 2D projections of 3D dynamical systems
let systems = [];
let time = 0;
const SYSTEM_COUNT = 4;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  
  for (let i = 0; i < SYSTEM_COUNT; i++) {
    systems.push(createSystem(i));
  }
}

function createSystem(index) {
  let types = ['rossler', 'thomas', 'halvorsen', 'actuator'];
  let type = types[index % types.length];
  
  let sys = {
    type: type,
    x: random(-2, 2),
    y: random(-2, 2),
    z: random(-2, 2),
    hue: (index * 90 + 200) % 360,
    scale: random(40, 80),
    offsetX: random(width * 0.2, width * 0.8),
    offsetY: random(height * 0.2, height * 0.8),
    trail: [],
    maxTrail: 600,
    params: getParams(type)
  };
  
  return sys;
}

function getParams(type) {
  switch(type) {
    case 'rossler':
      return { a: 0.2, b: 0.2, c: 5.7 };
    case 'thomas':
      return { b: 0.208186 };
    case 'halvorsen':
      return { a: 1.4, b: 0.3, c: 0.3 };
    case 'actuator':
      return { a: 0.2, b: 1.0, c: 1.0 };
    default:
      return {};
  }
}

function rossler(x, y, z, p, dt) {
  let dx = -y - z;
  let dy = x + p.a * y;
  let dz = p.b + z * (x - p.c);
  return [x + dx * dt, y + dy * dt, z + dz * dt];
}

function thomas(x, y, z, p, dt) {
  let dx = -p.b * x + sin(y);
  let dy = -p.b * y + sin(z);
  let dz = -p.b * z + sin(x);
  return [x + dx * dt, y + dy * dt, z + dz * dt];
}

function halvorsen(x, y, z, p, dt) {
  let dx = -p.a * x - 4 * y - 4 * z - y * y;
  let dy = -p.a * y - 4 * z - 4 * x - z * z;
  let dz = -p.a * z - 4 * x - 4 * y - x * x;
  return [x + dx * dt, y + dy * dt, z + dz * dt];
}

function actuator(x, y, z, p, dt) {
  let dx = y;
  let dy = -p.a * p.a * x - 2 * p.b * y + p.c * z;
  let dz = -p.c * sin(x);
  return [x + dx * dt, y + dy * dt, z + dz * dt];
}

function updateSystem(sys) {
  let dt = 0.02;
  let p = sys.params;
  
  let newVals;
  switch(sys.type) {
    case 'rossler': newVals = rossler(sys.x, sys.y, sys.z, p, dt); break;
    case 'thomas': newVals = thomas(sys.x, sys.y, sys.z, p, dt); break;
    case 'halvorsen': newVals = halvorsen(sys.x, sys.y, sys.z, p, dt); break;
    case 'actuator': newVals = actuator(sys.x, sys.y, sys.z, p, dt); break;
  }
  
  sys.x = newVals[0];
  sys.y = newVals[1];
  sys.z = newVals[2];
  
  // Store projected position (x-y plane projection with z as size)
  let px = sys.offsetX + sys.x * sys.scale;
  let py = sys.offsetY + sys.y * sys.scale;
  
  sys.trail.push({x: px, y: py, z: sys.z});
  
  if (sys.trail.length > sys.maxTrail) {
    sys.trail.shift();
  }
}

function draw() {
  background(240, 30, 1.5, 0.04);
  
  time += 0.01;
  
  for (let sys of systems) {
    updateSystem(sys);
    drawSystem(sys);
  }
}

function drawSystem(sys) {
  // Draw axis hint
  stroke(sys.hue, 20, 30, 0.1);
  strokeWeight(1);
  line(sys.offsetX - 30, sys.offsetY, sys.offsetX + 30, sys.offsetY);
  line(sys.offsetX, sys.offsetY - 30, sys.offsetX, sys.offsetY + 30);
  
  // Draw trail with depth
  noStroke();
  for (let i = 1; i < sys.trail.length; i++) {
    let prev = sys.trail[i-1];
    let curr = sys.trail[i];
    let progress = i / sys.trail.length;
    
    // Depth affects size and opacity
    let depthFactor = map(curr.z, -10, 10, 0.5, 1.5);
    let alpha = progress * 0.5;
    let size = (2 + progress * 3) * depthFactor;
    
    // Color shifts with progress
    let hue = (sys.hue + progress * 40) % 360;
    fill(hue, 50 + progress * 30, 80, alpha);
    ellipse(curr.x, curr.y, size);
  }
  
  // Draw current point with glow
  if (sys.trail.length > 0) {
    let curr = sys.trail[sys.trail.length - 1];
    let depthFactor = map(curr.z, -10, 10, 0.5, 1.5);
    
    // Outer glow
    fill(sys.hue, 40, 60, 0.15);
    ellipse(curr.x, curr.y, 25 * depthFactor);
    
    // Inner glow
    fill(sys.hue, 50, 80, 0.3);
    ellipse(curr.x, curr.y, 12 * depthFactor);
    
    // Core
    fill((sys.hue + 30) % 360, 20, 100, 0.9);
    ellipse(curr.x, curr.y, 4 * depthFactor);
  }
  
  // System label
  fill(sys.hue, 30, 50, 0.4);
  noStroke();
  textFont('monospace');
  textSize(10);
  text(sys.type.toUpperCase(), sys.offsetX - 30, sys.offsetY + sys.scale + 20);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  for (let sys of systems) {
    sys.offsetX = random(width * 0.2, width * 0.8);
    sys.offsetY = random(height * 0.2, height * 0.8);
    sys.trail = [];
  }
}
</script>
</body>
</html>
