<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>tension-nodes</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #050505; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// TENSION NODES - Geometric nodes connected by shifting tension lines
let nodes = [];
let numNodes = 12;
let time = 0;
let connections = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  
  // Initialize nodes in circular arrangement
  for (let i = 0; i < numNodes; i++) {
    let angle = (i / numNodes) * TWO_PI;
    let radius = min(width, height) * 0.3;
    nodes.push({
      baseX: width / 2 + cos(angle) * radius,
      baseY: height / 2 + sin(angle) * radius,
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      radius: random(8, 20),
      hue: random(0, 30), // Red/orange palette
      phase: random(TWO_PI),
      connectionIndices: []
    });
  }
  
  // Create connections between nearby nodes
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      let d = dist(nodes[i].baseX, nodes[i].baseY, nodes[j].baseX, nodes[j].baseY);
      if (d < min(width, height) * 0.4) {
        connections.push({ a: i, b: j });
        nodes[i].connectionIndices.push(j);
        nodes[j].connectionIndices.push(i);
      }
    }
  }
  
  // Set initial positions
  for (let n of nodes) {
    n.x = n.baseX;
    n.y = n.baseY;
  }
}

function draw() {
  background(0, 0, 2, 0.12);
  
  time += 0.02;
  
  // Update node physics
  for (let n of nodes) {
    // Orbital motion around base position
    let orbitX = sin(time * 0.5 + n.phase) * 30;
    let orbitY = cos(time * 0.4 + n.phase * 1.3) * 30;
    
    let targetX = n.baseX + orbitX;
    let targetY = n.baseY + orbitY;
    
    // Spring to target
    n.vx += (targetX - n.x) * 0.02;
    n.vy += (targetY - n.y) * 0.02;
    
    // Damping
    n.vx *= 0.92;
    n.vy *= 0.92;
    
    // Add slight drift
    n.vx += random(-0.1, 0.1);
    n.vy += random(-0.1, 0.1);
    
    n.x += n.vx;
    n.y += n.vy;
  }
  
  // Node-to-node forces
  for (let i = 0; i < connections.length; i++) {
    let c = connections[i];
    let n1 = nodes[c.a];
    let n2 = nodes[c.b];
    
    let dx = n2.x - n1.x;
    let dy = n2.y - n1.y;
    let d = sqrt(dx * dx + dy * dy);
    let restLength = 150;
    
    // Spring force
    let force = (d - restLength) * 0.005;
    let fx = (dx / d) * force;
    let fy = (dy / d) * force;
    
    n1.vx += fx;
    n1.vy += fy;
    n2.vx -= fx;
    n2.vy -= fy;
  }
  
  // Draw connections first (behind nodes)
  drawConnections();
  
  // Draw nodes
  drawNodes();
}

function drawConnections() {
  for (let c of connections) {
    let n1 = nodes[c.a];
    let n2 = nodes[c.b];
    
    let dx = n2.x - n1.x;
    let dy = n2.y - n1.y;
    let d = sqrt(dx * dx + dy * dy);
    
    // Tension affects color and opacity
    let tension = map(d, 100, 250, 1, 0);
    tension = constrain(tension, 0, 1);
    
    let alpha = tension * 0.6 + 0.1;
    let hue = map(tension, 0, 1, 20, 0); // Red to orange
    
    // Multiple line layers for glow
    for (let w = 8; w >= 1; w -= 2) {
      let a = alpha * map(w, 8, 1, 0.1, 1);
      stroke(hue, 80, 60, a);
      strokeWeight(w);
      line(n1.x, n1.y, n2.x, n2.y);
    }
    
    // Center bright line
    stroke(hue, 60, 90, alpha * 1.5);
    strokeWeight(1);
    line(n1.x, n1.y, n2.x, n2.y);
  }
}

function drawNodes() {
  for (let n of nodes) {
    // Outer glow
    for (let r = n.radius * 4; r > n.radius; r -= 3) {
      let alpha = map(r, n.radius, n.radius * 4, 0.3, 0);
      fill(n.hue, 70, 50, alpha);
      noStroke();
      ellipse(n.x, n.y, r * 2);
    }
    
    // Core
    fill(n.hue, 80, 80, 0.9);
    noStroke();
    ellipse(n.x, n.y, n.radius * 2);
    
    // Inner bright spot
    fill(n.hue, 30, 100, 0.8);
    ellipse(n.x, n.y, n.radius * 0.6);
    
    // Pulsing ring
    let ringSize = n.radius * 2 + sin(time * 2 + n.phase) * 5;
    noFill();
    stroke(n.hue, 60, 80, 0.4);
    strokeWeight(1);
    ellipse(n.x, n.y, ringSize * 2);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  
  // Recalculate base positions
  let radius = min(width, height) * 0.3;
  for (let i = 0; i < nodes.length; i++) {
    let angle = (i / numNodes) * TWO_PI;
    nodes[i].baseX = width / 2 + cos(angle) * radius;
    nodes[i].baseY = height / 2 + sin(angle) * radius;
  }
}
</script>
</body>
</html>
