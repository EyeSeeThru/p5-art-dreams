<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Thermal Drift</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #0a0a0a; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// Thermal Drift - GLSL shader exploration
// Technique: Raymarched noise field with temperature-based coloring

let shader;
let time = 0;

const vert = `
  attribute vec3 aPosition;
  attribute vec2 aTexCoord;
  varying vec2 vTexCoord;
  void main() {
    vTexCoord = aTexCoord;
    vec4 positionVec4 = vec4(aPosition, 1.0);
    positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
    gl_Position = positionVec4;
  }
`;

const frag = `
  precision highp float;
  varying vec2 vTexCoord;
  uniform float uTime;
  uniform vec2 uResolution;

  // Simplex noise functions
  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
  vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

  float snoise(vec3 v) {
    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
    vec3 i = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;
    i = mod289(i);
    vec4 p = permute(permute(permute(
      i.z + vec4(0.0, i1.z, i2.z, 1.0))
      + i.y + vec4(0.0, i1.y, i2.y, 1.0))
      + i.x + vec4(0.0, i1.x, i2.x, 1.0));
    float n_ = 0.142857142857;
    vec3 ns = n_ * D.wyz - D.xzx;
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_);
    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
  }

  // FBM - Fractal Brownian Motion
  float fbm(vec3 p) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    for (int i = 0; i < 5; i++) {
      value += amplitude * snoise(p * frequency);
      amplitude *= 0.5;
      frequency *= 2.0;
    }
    return value;
  }

  void main() {
    vec2 uv = vTexCoord;
    vec2 p = (gl_FragCoord.xy * 2.0 - uResolution) / min(uResolution.x, uResolution.y);
    
    float t = uTime * 0.15;
    
    // Layered noise for painterly effect
    vec3 q = vec3(p * 1.5, t);
    float n1 = fbm(q);
    float n2 = fbm(q + vec3(5.2, 1.3, 2.8));
    float n3 = fbm(q + vec3(n1 * 0.5, n2 * 0.5, t * 0.5));
    
    // Temperature-based coloring (thermal drift aesthetic)
    float temp = n1 * 0.5 + n2 * 0.3 + n3 * 0.2;
    temp = temp * 0.5 + 0.5; // normalize
    
    // Color palette: deep blues to hot oranges
    vec3 col1 = vec3(0.02, 0.02, 0.08);   // deep void
    vec3 col2 = vec3(0.1, 0.2, 0.4);       // cold blue
    vec3 col3 = vec3(0.6, 0.3, 0.1);       // warm amber
    vec3 col4 = vec3(1.0, 0.7, 0.3);       // hot orange
    vec3 col5 = vec3(1.0, 0.95, 0.8);      // white hot
    
    vec3 color;
    if (temp < 0.25) {
      color = mix(col1, col2, temp * 4.0);
    } else if (temp < 0.5) {
      color = mix(col2, col3, (temp - 0.25) * 4.0);
    } else if (temp < 0.75) {
      color = mix(col3, col4, (temp - 0.5) * 4.0);
    } else {
      color = mix(col4, col5, (temp - 0.75) * 4.0);
    }
    
    // Add subtle grain for painterly feel
    float grain = (fract(sin(dot(uv * 500.0, vec2(12.9898, 78.233))) * 43758.5453) - 0.5) * 0.03;
    color += grain;
    
    // Vignette
    float vig = 1.0 - length(p) * 0.3;
    color *= vig;
    
    gl_FragColor = vec4(color, 1.0);
  }
`;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  shader = createShader(vert, frag);
  noStroke();
}

function draw() {
  shader.setUniform('uTime', time);
  shader.setUniform('uResolution', [width, height]);
  shader(shader);
  rect(0, 0, width, height);
  time += deltaTime * 0.001;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
