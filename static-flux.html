<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>static-flux</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #0a0a0c; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// STATIC FLUX - Interference patterns from conflicting signal sources
let sources = [];
let numSources = 5;
let time = 0;
let gridPoints = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  
  // Create signal sources
  for (let i = 0; i < numSources; i++) {
    sources.push({
      x: random(width),
      y: random(height),
      vx: random(-1.5, 1.5),
      vy: random(-1, 1),
      frequency: random(0.01, 0.04),
      phase: random(TWO_PI),
      amplitude: random(80, 200)
    });
  }
  
  // Initialize grid points
  initGrid();
}

function initGrid() {
  let spacing = 20;
  gridPoints = [];
  
  for (let x = 0; x < width; x += spacing) {
    for (let y = 0; y < height; y += spacing) {
      gridPoints.push({
        x, y,
        baseX: x,
        baseY: y
      });
    }
  }
}

function draw() {
  background(240, 20, 2, 0.1);
  
  time += 0.03;
  
  // Update sources
  for (let s of sources) {
    s.x += s.vx;
    s.y += s.vy;
    
    // Bounce off edges
    if (s.x < 0 || s.x > width) s.vx *= -1;
    if (s.y < 0 || s.y > height) s.vy *= -1;
  }
  
  // Draw interference field
  drawInterferenceField();
  
  // Draw source indicators
  drawSources();
}

function drawInterferenceField() {
  let spacing = 15;
  
  for (let x = 0; x < width; x += spacing) {
    for (let y = 0; y < height; y += spacing) {
      // Calculate interference from all sources
      let totalFlux = 0;
      
      for (let s of sources) {
        let d = dist(x, y, s.x, s.y);
        let signal = sin(d * s.frequency - time + s.phase) * s.amplitude;
        let falloff = 1 / (1 + d * 0.01);
        totalFlux += signal * falloff;
      }
      
      // Map flux to color and position
      let normalizedFlux = map(totalFlux, -300, 300, 0, 1);
      let hue = map(normalizedFlux, 0, 1, 0, 60); // Red to orange/yellow
      
      // Displacement based on flux
      let displaceX = sin(normalizedFlux * PI + time) * 8;
      let displaceY = cos(normalizedFlux * PI + time * 0.7) * 8;
      
      let px = x + displaceX;
      let py = y + displaceY;
      
      // Draw point
      let brightness = map(normalizedFlux, 0, 1, 10, 60);
      let alpha = map(normalizedFlux, 0.3, 0.7, 0.1, 0.6);
      
      noStroke();
      fill(hue, 70, brightness, alpha);
      
      let size = map(normalizedFlux, 0, 1, 1, 5);
      ellipse(px, py, size, size);
    }
  }
  
  // Draw interference lines between sources
  for (let i = 0; i < sources.length; i++) {
    for (let j = i + 1; j < sources.length; j++) {
      let s1 = sources[i];
      let s2 = sources[j];
      
      let d = dist(s1.x, s1.y, s2.x, s2.y);
      
      if (d < 400) {
        let numPoints = floor(d / 15);
        
        for (let k = 0; k <= numPoints; k++) {
          let t = k / numPoints;
          let x = lerp(s1.x, s2.x, t);
          let y = lerp(s1.y, s2.y, t);
          
          // Interference at this point
          let interference = 0;
          for (let s of sources) {
            let sd = dist(x, y, s.x, s.y);
            interference += sin(sd * s.frequency - time + s.phase);
          }
          
          let alpha = map(d, 0, 400, 0.4, 0.05);
          let hue = map(sin(interference + time), -1, 1, 340, 30);
          
          stroke(hue, 60, 50, alpha);
          strokeWeight(1);
          point(x, y);
        }
      }
    }
  }
}

function drawSources() {
  for (let s of sources) {
    // Outer glow
    for (let i = 3; i >= 0; i--) {
      let size = s.amplitude * 0.3 + i * 20;
      let alpha = 0.15 - i * 0.03;
      
      noStroke();
      fill(0, 0, 80, alpha);
      ellipse(s.x, s.y, size, size);
    }
    
    // Core
    let pulse = sin(time * 3 + s.phase) * 0.3 + 0.7;
    noStroke();
    fill(10, 80, 90, pulse * 0.8);
    ellipse(s.x, s.y, 15 * pulse, 15 * pulse);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  initGrid();
}
</script>
</body>
</html>
