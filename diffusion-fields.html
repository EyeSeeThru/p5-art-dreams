<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>diffusion-fields</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #030305; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// DIFFUSION FIELDS - Particles spreading like ink in water with organic color bleeding
let particles = [];
let fields = [];
const PARTICLE_COUNT = 400;
const FIELD_COUNT = 5;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  noStroke();
  
  // Create attractor/repulsor fields
  for (let i = 0; i < FIELD_COUNT; i++) {
    fields.push({
      x: random(width),
      y: random(height),
      vx: random(-0.5, 0.5),
      vy: random(-0.5, 0.5),
      strength: random(80, 200),
      isAttractor: random() > 0.5,
      hue: random(0, 360),
      radius: random(100, 250)
    });
  }
  
  // Initialize particles
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    particles.push(createParticle());
  }
}

function createParticle() {
  // Start particles clustered near center
  let angle = random(TWO_PI);
  let r = random(50);
  return {
    x: width/2 + cos(angle) * r,
    y: height/2 + sin(angle) * r,
    vx: random(-0.5, 0.5),
    vy: random(-0.5, 0.5),
    hue: random(180, 280),
    size: random(2, 8),
    life: 1,
    decay: random(0.001, 0.003)
  };
}

function draw() {
  background(240, 30, 1, 0.06);
  
  // Update and draw fields
  for (let f of fields) {
    f.x += f.vx;
    f.y += f.vy;
    
    // Bounce off edges
    if (f.x < 0 || f.x > width) f.vx *= -1;
    if (f.y < 0 || f.y > height) f.vy *= -1;
    
    // Draw field influence
    for (let layer = 3; layer >= 0; layer--) {
      let alpha = 0.03 * (1 - layer * 0.25);
      fill(f.hue, 60, 80, alpha);
      ellipse(f.x, f.y, f.radius * (1 + layer * 0.5));
    }
  }
  
  // Update and draw particles
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    
    // Apply field forces
    for (let f of fields) {
      let dx = f.x - p.x;
      let dy = f.y - p.y;
      let d = sqrt(dx*dx + dy*dy);
      
      if (d < f.radius && d > 1) {
        let force = f.strength / (d * d) * 0.1;
        let dir = f.isAttractor ? 1 : -1;
        p.vx += (dx / d) * force * dir;
        p.vy += (dy / d) * force * dir;
        
        // Color bleeding near fields
        if (d < f.radius * 0.3) {
          p.hue = lerp(p.hue, f.hue, 0.02);
        }
      }
    }
    
    // Add noise-based wandering
    let noiseScale = 0.01;
    p.vx += (noise(p.x * noiseScale, frameCount * 0.01) - 0.5) * 0.3;
    p.vy += (noise(p.y * noiseScale, frameCount * 0.01 + 100) - 0.5) * 0.3;
    
    // Damping
    p.vx *= 0.98;
    p.vy *= 0.98;
    
    // Update position
    p.x += p.vx;
    p.y += p.vy;
    
    // Life decay
    p.life -= p.decay;
    
    // Respawn if dead or out of bounds
    if (p.life <= 0 || p.x < -50 || p.x > width + 50 || p.y < -50 || p.y > height + 50) {
      particles[i] = createParticle();
      continue;
    }
    
    // Draw particle with glow
    let size = p.size * p.life;
    
    // Outer glow
    fill(p.hue, 50, 80, p.life * 0.15);
    ellipse(p.x, p.y, size * 3);
    
    // Core
    fill(p.hue, 70, 100, p.life * 0.6);
    ellipse(p.x, p.y, size);
  }
  
  // Draw connections between nearby particles
  strokeWeight(0.5);
  for (let i = 0; i < particles.length; i++) {
    for (let j = i + 1; j < particles.length; j++) {
      let d = dist(particles[i].x, particles[i].y, particles[j].x, particles[j].y);
      if (d < 40) {
        let alpha = map(d, 0, 40, 0.08, 0);
        let avgHue = (particles[i].hue + particles[j].hue) / 2;
        stroke(avgHue, 40, 80, alpha);
        line(particles[i].x, particles[i].y, particles[j].x, particles[j].y);
      }
    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
